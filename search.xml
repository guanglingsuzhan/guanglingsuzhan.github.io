<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础内容：排序的理解</title>
      <link href="/2022/08/05/02/"/>
      <url>/2022/08/05/02/</url>
      
        <content type="html"><![CDATA[<h1 id="在这里探讨所有的排序-加深记忆，希望自己在总结的时候有新的思考和理解，可能有抄袭其他blog的方面，希望没有造成困扰。"><a href="#在这里探讨所有的排序-加深记忆，希望自己在总结的时候有新的思考和理解，可能有抄袭其他blog的方面，希望没有造成困扰。" class="headerlink" title="在这里探讨所有的排序,加深记忆，希望自己在总结的时候有新的思考和理解，可能有抄袭其他blog的方面，希望没有造成困扰。"></a>在这里探讨所有的排序,加深记忆，希望自己在总结的时候有新的思考和理解，可能有抄袭其他blog的方面，希望没有造成困扰。</h1><h2 id="排序之间的关系"><a href="#排序之间的关系" class="headerlink" title="排序之间的关系"></a>排序之间的关系</h2><p><img src="https://6d69-mine2-93691a-1302872319.tcb.qcloud.la/blog/img/1.jpg" alt="Alt"></p><span id="more"></span><table border="1" cellpadding="1" cellspacing="1">    <tbody><tr>        <td rowspan="2">类别</td>         <td rowspan="2">排序方法</td>         <td colspan="4" align="center">时间复杂度</td>         <td rowspan="2">稳定性</td>   </tr>   <tr>       <td>平均情况</td>        <td>最好情况</td>        <td>最坏情况</td>       <td>辅助存储</td>   </tr>    <tr>        <td rowspan="2">插入排序</td>           <td>直接插入</td>         <td>O(n^2)</td>         <td>O(n)</td>        <td>O(n^2)</td>        <td>O(1)</td>        <td>稳定</td>    </tr>   <tr>        <td>希尔排序</td>        <td>O(n^1.3)</td>         <td>O(n)</td>        <td>O(n^2)</td>        <td>O(1)</td>        <td>不稳定</td>   </tr>     <tr>        <td rowspan="2">选择排序</td>    </tr>    <tr>        <td rowspan="2">选择排序</td>    </tr></tbody></table><ul><li>表中的希尔排序的算法复杂度其实并没有理解实际的原理，各个blog有自己的写法，无法从中看到最合理的解释，将来从专业文献获得方法。</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>算法基本思想<br>在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[]  insertSort(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; nums[j]; j--) {</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];  <span class="comment">//将大于temp的值整体后移一个单位</span></span><br><span class="line">            }</span><br><span class="line">            nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>算法基本思想<br>算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。</li><li>感想<br>希尔排序实质就是分组插入排序，</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] publicshellSort(<span class="type">int</span>[] nums) {</span><br><span class="line">      <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> nums.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">          d1 = Math.ceil(d1 / <span class="number">2</span>);</span><br><span class="line">          <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">int</span>) d1;</span><br><span class="line">          <span class="comment">/*分组*/</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; d; x++) {</span><br><span class="line">             <span class="comment">/* 插入排序*/</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x + d; i &lt; nums.length; i += d) {</span><br><span class="line">                  <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - d;</span><br><span class="line">                  temp = nums[i];</span><br><span class="line">                  <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; nums[j]; j -= d) {</span><br><span class="line">                      nums[j + d] = nums[j];</span><br><span class="line">                  }</span><br><span class="line">                  nums[j + d] = temp;</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (d == <span class="number">1</span>) {</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> nums;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java的Stack的思考</title>
      <link href="/2022/08/04/01/"/>
      <url>/2022/08/04/01/</url>
      
        <content type="html"><![CDATA[<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>按照官方文档的说法，如果要在java中实现stack，应该用双端队列，</p><span id="more"></span><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span><br></pre></td></tr></tbody></table></figure><p>参考其他博客的说法，继承属于生活中的抽象概念，属于少数情况，组合才是生活中的大多数情况，</p><h3 id="Vector和ArrayList的相同点和不同点"><a href="#Vector和ArrayList的相同点和不同点" class="headerlink" title="Vector和ArrayList的相同点和不同点"></a>Vector和ArrayList的相同点和不同点</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li>底层的实现都是Object[]数组</li><li>初始的数组容量都是10</li><li>构建时都能指定容量</li><li>容量不够的时候，都会自动扩容（ArrayList集合的自动扩容的新容量是原来的1.5倍,Vector集合的自动扩容的新容量是原来的2倍。）</li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li>Vector线程安全，ArrayList线程不安全。</li></ul><h3 id="如何将非线程安全的List转成线程安全的List？"><a href="#如何将非线程安全的List转成线程安全的List？" class="headerlink" title="如何将非线程安全的List转成线程安全的List？"></a>如何将非线程安全的List转成线程安全的List？</h3><p>使用Collections.synchronizedList(list list)方法<br>（注意遍历的时候需要先在同步代码块里面）</p><h3 id="关于数组和链表的思考"><a href="#关于数组和链表的思考" class="headerlink" title="关于数组和链表的思考"></a>关于数组和链表的思考</h3><p>大家可以看到，Java 官方推荐的创建栈的方式，使用了 Deque 接口。并且，在底层实现上，使用了 ArrayDeque，也就是基于动态数组的实现。为什么？</p><p>大家应该都知道，动态数组是可以进行扩容操作的。在触发扩容的时候，时间复杂度是 O(n) 的，但整体平均时间复杂度（Amortized Time）是 O(1)。</p><p>但是，基于链表的实现，不会牵扯到扩容问题，因此，每一次添加操作，从时间复杂度的角度，都是 O(1) 的。</p><p>虽然如此，可是实际上，当数据量达到一定程度的时候，链表的性能是远远低于动态数组的。</p><p>这是因为，对于链表来说，每添加一个元素，都需要重新创建一个 Node 类的对象，也就是都需要进行一次 new 的内存操作。而对内存的操作，是非常慢的。</p><p>举个例子，对于队列，假设我们实验使用 ArrayDeque（动态数组）和 LinkedList（链表）作为底层的数据结构，进行 1000 万次入队操作。并且测试他们的性能。代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q1 = new ArrayDeque&lt;&gt;();</span><br><span class="line">Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();</span><br><span class="line">int N = 10000000;</span><br><span class="line">long start1 = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; N; i++) q1.offer(i);</span><br><span class="line">System.out.println((System.currentTimeMillis() - start1) + "ms");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">long start2 = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; N; i++) q2.offer(i);</span><br><span class="line">System.out.println((System.currentTimeMillis() - start2) + "ms");</span><br></pre></td></tr></tbody></table></figure><p>测试结果表明LinkedList会比ArrayDeque慢五倍以上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
